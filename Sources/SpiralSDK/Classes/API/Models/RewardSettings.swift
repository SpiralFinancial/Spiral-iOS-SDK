//
// RewardSettings.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Reward settings that can have a certain type. Selected type is the prefix of the required property to set */
public struct RewardSettings: Codable, JSONEncodable, Hashable {

    public enum ModelType: String, Codable, CaseIterable {
        case userSponsored = "UserSponsored"
        case bankSponsored = "BankSponsored"
    }
    public enum UserSponsoredRewardType: String, Codable, CaseIterable {
        case roundup = "roundUp"
    }
    public enum UserSponsoredValue: String, Codable, CaseIterable {
        case dollar = "dollar"
        case fiveDollars = "five_dollars"
        case tenDollars = "ten_dollars"
    }
    public enum BankSponsoredRewardType: String, Codable, CaseIterable {
        case units = "units"
        case money = "money"
    }
    public var type: ModelType
    /** Reward type in use per transaction */
    public var userSponsoredRewardType: UserSponsoredRewardType?
    /** Available selections for the user sponsored reward type */
    public var userSponsoredValue: UserSponsoredValue?
    public var userSponsoredRewardLimits: RewardLimits?
    /** Reward type in use per transaction */
    public var bankSponsoredRewardType: BankSponsoredRewardType?
    /** Accepted value depending on the rewardType either a number of unit or dollar amount up to two decimal places */
    public var value: Double?

    public init(type: ModelType, userSponsoredRewardType: UserSponsoredRewardType? = nil, userSponsoredValue: UserSponsoredValue? = nil, userSponsoredRewardLimits: RewardLimits? = nil, bankSponsoredRewardType: BankSponsoredRewardType? = nil, value: Double? = nil) {
        self.type = type
        self.userSponsoredRewardType = userSponsoredRewardType
        self.userSponsoredValue = userSponsoredValue
        self.userSponsoredRewardLimits = userSponsoredRewardLimits
        self.bankSponsoredRewardType = bankSponsoredRewardType
        self.value = value
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case type
        case userSponsoredRewardType
        case userSponsoredValue
        case userSponsoredRewardLimits
        case bankSponsoredRewardType
        case value
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(userSponsoredRewardType, forKey: .userSponsoredRewardType)
        try container.encodeIfPresent(userSponsoredValue, forKey: .userSponsoredValue)
        try container.encodeIfPresent(userSponsoredRewardLimits, forKey: .userSponsoredRewardLimits)
        try container.encodeIfPresent(bankSponsoredRewardType, forKey: .bankSponsoredRewardType)
        try container.encodeIfPresent(value, forKey: .value)
    }
}

