//
// DepositoryOrCreditTransaction.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Describes a transaction against a debit or credit card account. */
public struct DepositoryOrCreditTransaction: Codable, JSONEncodable, Hashable {

    /** Permanent, unique transaction identifier. Must survive changes to pending status or amount. */
    public var transactionId: String
    /** Unique customer ID */
    public var customerId: String?
    /** References to the account that this transaction is posting against. */
    public var accountId: String?
    /** Description of the transaction. */
    public var description: String?
    /** Addenda or distinguishing information for the transaction. */
    public var name: String?
    /** Hierarchical categorization, use multi-valued array to indicate hierarchy. */
    public var category: [String]?
    /** Flat categorization. For hashtags omit leading #. */
    public var tags: [String]?
    /** Fixed-point decimal number, carried up to two decimal places. */
    public var endingBalance: Double?
    /** The date/time when the transaction was authorized, in the time zone local to the transaction or to the customer. */
    public var transactedAtDate: Date
    /** The date/time when the transaction settled, in the time zone local to the customer. Must be null if the transaction is pending. */
    public var settledAtDate: Date?
    /** Reference to the identity of the merchant related to this transaction. */
    public var merchantCategoryCode: String
    public var geolocation: GeoLocation?
    /** The ISO 4217 currency in which this transaction is denominated. One of either the currency or non_iso_currency fields is required. */
    public var currency: String?
    /** If the transaction is denominated in a non-ISO currency, provide the currency's symbol. */
    public var nonIsoCurrency: String?
    public var type: DepositoryOrCreditTransactionType
    public var method: DepositoryOrCreditTransactionMethod
    /** Indicates that this transaction has not posted. */
    public var isPending: Bool?
    public var status: TransactionStatus
    /** Fixed-point decimal number, carried up to two decimal places. */
    public var transactionAmount: Double?
    /** Fixed-point decimal number, carried up to two decimal places. */
    public var feeAmount: Double?
    /** If this transaction is an internal transfer type, references the accountId associated with this transaction. */
    public var transferAccountId: String?

    public init(transactionId: String, customerId: String? = nil, accountId: String? = nil, description: String? = nil, name: String? = nil, category: [String]? = nil, tags: [String]? = nil, endingBalance: Double? = nil, transactedAtDate: Date, settledAtDate: Date? = nil, merchantCategoryCode: String, geolocation: GeoLocation? = nil, currency: String? = nil, nonIsoCurrency: String? = nil, type: DepositoryOrCreditTransactionType, method: DepositoryOrCreditTransactionMethod, isPending: Bool? = nil, status: TransactionStatus, transactionAmount: Double? = nil, feeAmount: Double? = nil, transferAccountId: String? = nil) {
        self.transactionId = transactionId
        self.customerId = customerId
        self.accountId = accountId
        self.description = description
        self.name = name
        self.category = category
        self.tags = tags
        self.endingBalance = endingBalance
        self.transactedAtDate = transactedAtDate
        self.settledAtDate = settledAtDate
        self.merchantCategoryCode = merchantCategoryCode
        self.geolocation = geolocation
        self.currency = currency
        self.nonIsoCurrency = nonIsoCurrency
        self.type = type
        self.method = method
        self.isPending = isPending
        self.status = status
        self.transactionAmount = transactionAmount
        self.feeAmount = feeAmount
        self.transferAccountId = transferAccountId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case transactionId
        case customerId
        case accountId
        case description
        case name
        case category
        case tags
        case endingBalance
        case transactedAtDate
        case settledAtDate
        case merchantCategoryCode
        case geolocation
        case currency
        case nonIsoCurrency
        case type
        case method
        case isPending
        case status
        case transactionAmount
        case feeAmount
        case transferAccountId
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(transactionId, forKey: .transactionId)
        try container.encodeIfPresent(customerId, forKey: .customerId)
        try container.encodeIfPresent(accountId, forKey: .accountId)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(category, forKey: .category)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(endingBalance, forKey: .endingBalance)
        try container.encode(transactedAtDate, forKey: .transactedAtDate)
        try container.encodeIfPresent(settledAtDate, forKey: .settledAtDate)
        try container.encode(merchantCategoryCode, forKey: .merchantCategoryCode)
        try container.encodeIfPresent(geolocation, forKey: .geolocation)
        try container.encodeIfPresent(currency, forKey: .currency)
        try container.encodeIfPresent(nonIsoCurrency, forKey: .nonIsoCurrency)
        try container.encode(type, forKey: .type)
        try container.encode(method, forKey: .method)
        try container.encodeIfPresent(isPending, forKey: .isPending)
        try container.encode(status, forKey: .status)
        try container.encodeIfPresent(transactionAmount, forKey: .transactionAmount)
        try container.encodeIfPresent(feeAmount, forKey: .feeAmount)
        try container.encodeIfPresent(transferAccountId, forKey: .transferAccountId)
    }
}

